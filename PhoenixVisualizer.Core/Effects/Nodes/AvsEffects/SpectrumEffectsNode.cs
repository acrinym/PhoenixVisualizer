using System; using System.Collections.Generic; using PhoenixVisualizer.Core.Effects.Models; using PhoenixVisualizer.Core.Models; namespace PhoenixVisualizer.Core.Effects.Nodes.AvsEffects { public class SpectrumEffectsNode : BaseEffectNode { public int SpectrumType { get; set; } = 0; public float Scale { get; set; } = 1.0f; public int Color { get; set; } = 0xFFFFFF; public bool BeatReactive { get; set; } = false; public float BeatScale { get; set; } = 2.0f; public bool Smooth { get; set; } = false; public SpectrumEffectsNode() { Name = \
Spectrum
Effects\; Description = \Creates
spectrum
analyzer
visualizations
from
audio
frequency
data\; Category = \AVS
Effects\; } protected override void InitializePorts() { _inputPorts.Add(new EffectPort(\Image\, typeof(ImageBuffer), true, null, \Input
image
for
spectrum
overlay\)); _outputPorts.Add(new EffectPort(\Output\, typeof(ImageBuffer), false, null, \Spectrum
output
image\)); } protected override object ProcessCore(Dictionary<string, object> inputs, AudioFeatures audioFeatures) { if (!inputs.TryGetValue(\Image\, out var input) || input is not ImageBuffer imageBuffer) return GetDefaultOutput(); var output = new ImageBuffer(imageBuffer.Width, imageBuffer.Height); Array.Copy(imageBuffer.Pixels, output.Pixels, imageBuffer.Pixels.Length); if (audioFeatures?.Spectrum == null) return output; float currentScale = Scale; if (BeatReactive && audioFeatures?.IsBeat == true) { currentScale *= BeatScale; } switch (SpectrumType) { case 0: // Vertical bars RenderVerticalBars(output, audioFeatures.Spectrum, currentScale); break; case 1: // Horizontal bars RenderHorizontalBars(output, audioFeatures.Spectrum, currentScale); break; case 2: // Circular spectrum RenderCircularSpectrum(output, audioFeatures.Spectrum, currentScale); break; case 3: // 3D spectrum Render3DSpectrum(output, audioFeatures.Spectrum, currentScale); break; } return output; } private void RenderVerticalBars(ImageBuffer output, float[] spectrum, float scale) { int barWidth = output.Width / spectrum.Length; for (int i = 0; i < spectrum.Length && i * barWidth < output.Width; i++) { float value = spectrum[i] * scale; int barHeight = (int)(value * output.Height); int x = i * barWidth; for (int y = output.Height - 1; y >= output.Height - barHeight && y >= 0; y--) { output.SetPixel(x, y, Color); } } } private void RenderHorizontalBars(ImageBuffer output, float[] spectrum, float scale) { int barHeight = output.Height / spectrum.Length; for (int i = 0; i < spectrum.Length && i * barHeight < output.Height; i++) { float value = spectrum[i] * scale; int barWidth = (int)(value * output.Width); int y = i * barHeight; for (int x = 0; x < barWidth && x < output.Width; x++) { output.SetPixel(x, y, Color); } } } private void RenderCircularSpectrum(ImageBuffer output, float[] spectrum, float scale) { int centerX = output.Width / 2; int centerY = output.Height / 2; int radius = Math.Min(centerX, centerY) - 10; for (int i = 0; i < spectrum.Length && i < 360; i++) { float angle = (float)i * (float)Math.PI / 180.0f; float value = spectrum[i] * scale; int r = radius + (int)(value * radius * 0.5f); int x = centerX + (int)(r * Math.Cos(angle)); int y = centerY + (int)(r * Math.Sin(angle)); if (x >= 0 && x < output.Width && y >= 0 && y < output.Height) { output.SetPixel(x, y, Color); } } } private void Render3DSpectrum(ImageBuffer output, float[] spectrum, float scale) { int centerX = output.Width / 2; int centerY = output.Height / 2; for (int i = 0; i < spectrum.Length && i < output.Width; i++) { float value = spectrum[i] * scale; int barHeight = (int)(value * output.Height * 0.5f); int x = i; for (int y = output.Height - 1; y >= output.Height - barHeight && y >= 0; y--) { for (int z = 0; z < 5; z++) { int pixelY = y + z; if (pixelY >= 0 && pixelY < output.Height) { int alpha = 255 - (z * 50); int pixelColor = (alpha << 24) | Color; output.SetPixel(x, pixelY, pixelColor); } } } } } protected override object GetDefaultOutput() { return new ImageBuffer(1, 1); } } }
