using System; using System.Collections.Generic; using PhoenixVisualizer.Core.Effects.Models; using PhoenixVisualizer.Core.Models; namespace PhoenixVisualizer.Core.Effects.Nodes.AvsEffects { public class OscilloscopeEffectsNode : BaseEffectNode { public int OscilloscopeType { get; set; } = 0; public float Scale { get; set; } = 1.0f; public int Color { get; set; } = 0xFFFFFF; public bool BeatReactive { get; set; } = false; public float BeatScale { get; set; } = 2.0f; public OscilloscopeEffectsNode() { Name = \
Oscilloscope
Effects\; Description = \Creates
oscilloscope
visualizations
from
audio
waveform
data\; Category = \AVS
Effects\; } protected override void InitializePorts() { _inputPorts.Add(new EffectPort(\Image\, typeof(ImageBuffer), true, null, \Input
image
for
oscilloscope
overlay\)); _outputPorts.Add(new EffectPort(\Output\, typeof(ImageBuffer), false, null, \Oscilloscope
output
image\)); } protected override object ProcessCore(Dictionary<string, object> inputs, AudioFeatures audioFeatures) { if (!inputs.TryGetValue(\Image\, out var input) || input is not ImageBuffer imageBuffer) return GetDefaultOutput(); var output = new ImageBuffer(imageBuffer.Width, imageBuffer.Height); Array.Copy(imageBuffer.Pixels, output.Pixels, imageBuffer.Pixels.Length); if (audioFeatures?.Waveform == null) return output; float currentScale = Scale; if (BeatReactive && audioFeatures?.IsBeat == true) { currentScale *= BeatScale; } switch (OscilloscopeType) { case 0: // Standard oscilloscope RenderStandardOscilloscope(output, audioFeatures.Waveform, currentScale); break; case 1: // Circular oscilloscope RenderCircularOscilloscope(output, audioFeatures.Waveform, currentScale); break; case 2: // 3D oscilloscope Render3DOscilloscope(output, audioFeatures.Waveform, currentScale); break; } return output; } private void RenderStandardOscilloscope(ImageBuffer output, float[] waveform, float scale) { int centerY = output.Height / 2; for (int x = 0; x < output.Width && x < waveform.Length; x++) { int waveformIndex = (int)((float)x / output.Width * waveform.Length); float value = waveform[waveformIndex] * scale; int y = centerY + (int)(value * centerY); if (y >= 0 && y < output.Height) { output.SetPixel(x, y, Color); } } } private void RenderCircularOscilloscope(ImageBuffer output, float[] waveform, float scale) { int centerX = output.Width / 2; int centerY = output.Height / 2; int radius = Math.Min(centerX, centerY) - 10; for (int i = 0; i < waveform.Length && i < 360; i++) { float angle = (float)i * (float)Math.PI / 180.0f; float value = waveform[i] * scale; int r = radius + (int)(value * radius * 0.5f); int x = centerX + (int)(r * Math.Cos(angle)); int y = centerY + (int)(r * Math.Sin(angle)); if (x >= 0 && x < output.Width && y >= 0 && y < output.Height) { output.SetPixel(x, y, Color); } } } private void Render3DOscilloscope(ImageBuffer output, float[] waveform, float scale) { int centerX = output.Width / 2; int centerY = output.Height / 2; for (int x = 0; x < output.Width && x < waveform.Length; x++) { int waveformIndex = (int)((float)x / output.Width * waveform.Length); float value = waveform[waveformIndex] * scale; for (int z = 0; z < 10; z++) { int y = centerY + (int)(value * centerY * 0.5f) + z; if (y >= 0 && y < output.Height) { int alpha = 255 - (z * 25); int pixelColor = (alpha << 24) | Color; output.SetPixel(x, y, pixelColor); } } } } protected override object GetDefaultOutput() { return new ImageBuffer(1, 1); } } }
