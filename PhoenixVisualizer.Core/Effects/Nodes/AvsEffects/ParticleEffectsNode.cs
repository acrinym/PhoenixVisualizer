using System; using System.Collections.Generic; using PhoenixVisualizer.Core.Effects.Models; using PhoenixVisualizer.Core.Models; namespace PhoenixVisualizer.Core.Effects.Nodes.AvsEffects { public class ParticleEffectsNode : BaseEffectNode { public int NumParticles { get; set; } = 100; public float Gravity { get; set; } = 0.1f; public float Friction { get; set; } = 0.98f; public int ParticleColor { get; set; } = 0xFFFFFF; public bool BeatReactive { get; set; } = false; public float BeatGravity { get; set; } = 0.2f; private readonly List<Particle> particles = new List<Particle>(); private readonly Random random = new Random(); public ParticleEffectsNode() { Name = \
Particle
Effects\; Description = \Creates
dynamic
particle
systems
with
physics
simulation\; Category = \AVS
Effects\; InitializeParticles(); } private void InitializeParticles() { particles.Clear(); for (int i = 0; i < NumParticles; i++) { particles.Add(new Particle { X = random.Next(0, 800), Y = random.Next(0, 600), VX = (float)(random.NextDouble() - 0.5) * 2, VY = (float)(random.NextDouble() - 0.5) * 2, Life = 1.0f, Decay = (float)random.NextDouble() * 0.02f + 0.01f }); } } protected override void InitializePorts() { _inputPorts.Add(new EffectPort(\Image\, typeof(ImageBuffer), true, null, \Input
image
for
particle
overlay\)); _outputPorts.Add(new EffectPort(\Output\, typeof(ImageBuffer), false, null, \Particle
output
image\)); } protected override object ProcessCore(Dictionary<string, object> inputs, AudioFeatures audioFeatures) { if (!inputs.TryGetValue(\Image\, out var input) || input is not ImageBuffer imageBuffer) return GetDefaultOutput(); var output = new ImageBuffer(imageBuffer.Width, imageBuffer.Height); Array.Copy(imageBuffer.Pixels, output.Pixels, imageBuffer.Pixels.Length); float currentGravity = Gravity; if (BeatReactive && audioFeatures?.IsBeat == true) { currentGravity *= BeatGravity; } UpdateParticles(currentGravity); RenderParticles(output); return output; } private void UpdateParticles(float gravity) { for (int i = particles.Count - 1; i >= 0; i--) { var particle = particles[i]; particle.X += particle.VX; particle.Y += particle.VY; particle.VY += gravity; particle.VX *= Friction; particle.VY *= Friction; particle.Life -= particle.Decay; if (particle.Life <= 0 || particle.X < 0 || particle.X >= 800 || particle.Y < 0 || particle.Y >= 600) { particles.RemoveAt(i); } } if (particles.Count < NumParticles) { particles.Add(new Particle { X = random.Next(0, 800), Y = random.Next(0, 600), VX = (float)(random.NextDouble() - 0.5) * 2, VY = (float)(random.NextDouble() - 0.5) * 2, Life = 1.0f, Decay = (float)random.NextDouble() * 0.02f + 0.01f }); } } private void RenderParticles(ImageBuffer output) { foreach (var particle in particles) { int x = (int)particle.X; int y = (int)particle.Y; if (x >= 0 && x < output.Width && y >= 0 && y < output.Height) { int alpha = (int)(particle.Life * 255); int color = (alpha << 24) | ParticleColor; output.SetPixel(x, y, color); } } } private class Particle { public float X { get; set; } public float Y { get; set; } public float VX { get; set; } public float VY { get; set; } public float Life { get; set; } public float Decay { get; set; } } protected override object GetDefaultOutput() { return new ImageBuffer(1, 1); } } }
