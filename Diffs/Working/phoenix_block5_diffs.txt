--- a/PhoenixVisualizer.Visuals\PulseVisualizer.cs
+++ b/PhoenixVisualizer.Visuals\PulseVisualizer.cs
@@ -17,6 +17,8 @@
     private int _height;
     private float _time = 0f;
     private float _lastLevel = 0f;
+    private float _emaLevel = 0f;
+    private const float EMA_A = 0.35f;
     private float _lastBeatLevel = 0f;
     private float _beatPulsePhase = 0f;
 
@@ -47,8 +49,15 @@
         _time += 0.016f;
 
         canvas.Clear(0xFF000000);
-        
-        // Get audio data with proper scaling
+        // Band-weighted level
+        float level = (bass * 0.5f + mid * 0.35f + treble * 0.15f);
+        // EMA toward current to avoid "random" feel
+        _emaLevel = (_emaLevel == 0f) ? level : (_emaLevel * (1f - EMA_A) + level * EMA_A);
+        float beatBoost = beat ? 0.12f : 0f;
+        float pulse = MathF.Min(1f, _emaLevel + beatBoost);
+        // expose for subsequent drawing
+        float __pulseLevel = pulse;
+        //  Get audio data with proper scaling
         float energy = features.Energy;
         float rms = features.Rms;
         float volume = features.Volume;
@@ -202,7 +211,7 @@
         // Draw energy-based ripple effects
         for (int ripple = 0; ripple < 3; ripple++)
         {
-            float rippleRadius = maxRadius * (0.3f + ripple * 0.2f);
+            float rippleRadius = baseRadius * (0.6f + 0.8f * __pulseLevel);
             float rippleAlpha = energyLevel * (0.8f - ripple * 0.2f);
             byte alpha = (byte)(rippleAlpha * 255);
             


--- a/PhoenixVisualizer.Visuals\EnergyVisualizer.cs
+++ b/PhoenixVisualizer.Visuals\EnergyVisualizer.cs
@@ -17,6 +17,8 @@
     private int _height;
     private float _time = 0f;
     private float _lastLevel = 0f;
+    private float _emaLevel = 0f;
+    private const float EMA_A = 0.30f;
     private float _beatPulsePhase = 0f;
 
     // User parameters
@@ -94,12 +96,19 @@
             ringColor = _frequencyColor; // High frequencies
         }
         
-        // Apply intensity based on audio level
-        byte alpha = (byte)(smoothedLevel * 255);
+        // Apply intensity based on audio level with EMA smoothing
+        float level = (bass * 0.45f + mid * 0.35f + treble * 0.20f);
+        _emaLevel = (_emaLevel == 0f) ? level : (_emaLevel * (1f - EMA_A) + level * EMA_A);
+        float ringSize = MathF.Min(MathF.Min(_width, _height) * 0.45f, MathF.Max(24f, _emaLevel * MathF.Min(_width, _height) * 0.5f));
+        uint ringColor = _baseColor;
+        if (beat) ringColor = _beatColor;
+        byte alpha = (byte)Math.Clamp((_emaLevel * 255f), 24f, 255f);
         ringColor = (ringColor & 0x00FFFFFF) | ((uint)alpha << 24);
-
-        // Draw main ring
-        canvas.FillCircle(_width / 2f, _height / 2f, ringSize, ringColor);
+        float thickness = 4f + 8f * _emaLevel;
+        canvas.DrawCircle(_width/2f, _height/2f, ringSize, ringColor, false);
+        canvas.SetLineWidth(thickness);
+        canvas.DrawCircle(_width/2f, _height/2f, ringSize * 0.7f, ringColor, false);
+        (_width / 2f, _height / 2f, ringSize, ringColor);
 
         // Draw glow effect if enabled
         if (_showGlow && smoothedLevel > 0.1f)


--- a/PhoenixVisualizer.Visuals\CatFaceSuperscope.cs
+++ b/PhoenixVisualizer.Visuals\CatFaceSuperscope.cs
@@ -76,8 +76,11 @@
             facePoints.Add((x, y));
         }
         
-        // FIXED: Face outline responds to all audio frequencies
+        // Enhanced: all elements respond to bands
         uint faceColor = beat ? 0xFFFF8844 : 0xFFFFAA66; // Warm orange
+        var faceLineWidth = 3.0f + bass * 2.0f + energy * 1.0f;
+        canvas.DrawPolygon(CollectionsMarshal.AsSpan(facePoints), faceColor, false);
+        canvas.SetLineWidth(faceLineWidth); // Warm orange
         var faceLineWidth = 4.0f + bass * 2.0f + energy * 1.0f; // Line thickness responds to bass and energy
         canvas.SetLineWidth(faceLineWidth);
         canvas.DrawLines(facePoints.ToArray(), faceLineWidth, faceColor);


--- a/PhoenixVisualizer.Visuals\FlappyBirdVisualizer.cs
+++ b/PhoenixVisualizer.Visuals\FlappyBirdVisualizer.cs
@@ -267,9 +267,13 @@
 
             // Apply gravity
             bird.VelocityY += GRAVITY * 0.016f;
+            // Clamp upward velocity (prevents ceiling rockets)
+            if (bird.VelocityY < -450f) bird.VelocityY = -450f;
 
             // Update position
             bird.Y += bird.VelocityY * 0.016f;
+            // Ceiling clamp & bounce
+            if (bird.Y < 20f) { bird.Y = 20f; if (bird.VelocityY < 0) bird.VelocityY *= -0.3f; }
 
             // Update animation
             bird.AnimationTime += 0.016f * (1f + f.Treble * 2f);


--- a/PhoenixVisualizer.Visuals\Win2K3DText.cs
+++ b/PhoenixVisualizer.Visuals\Win2K3DText.cs
@@ -10,6 +10,11 @@
 /// FIXED: Now implements actual 3D text with enhanced audio reactivity instead of random patterns
 /// </summary>
 public sealed class Win2K3DText : IVisualizerPlugin
+{
+    private const int MAX_TRIANGLES_PER_FRAME = 30000;
+    private const int MAX_CHARS_PER_FRAME = 32;
+    private int _trianglesThisFrame = 0;
+    private int _charsThisFrame = 0;
 {
     public string Id => "win2k_3d_text";
     public string DisplayName => "ðŸ“ Win2K 3D Text";
@@ -101,6 +106,8 @@
 
     public void RenderFrame(AudioFeatures f, ISkiaCanvas canvas)
     {
+        _trianglesThisFrame = 0;
+        _charsThisFrame = 0;
         // FIXED: Audio-reactive time and animation updates
         var energy = f.Energy;
         var bass = f.Bass;
@@ -152,8 +159,9 @@
         float charSpacing = 1.2f;
         float startX = -text.Length * charSpacing * 0.5f;
 
-        for (int i = 0; i < text.Length; i++)
-        {
+        for (int i = 0; i < text.Length; i++) {
+            if (_charsThisFrame >= MAX_CHARS_PER_FRAME) break;
+            _charsThisFrame++;
             var textChar = new TextChar
             {
                 Character = text[i],


