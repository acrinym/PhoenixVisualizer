--- a/PhoenixVisualizer.Visuals\FlameFractal.cs
+++ b/PhoenixVisualizer.Visuals\FlameFractal.cs
@@ -83,8 +83,19 @@
 
     public void Dispose() { }
 
-    public void RenderFrame(AudioFeatures f, ISkiaCanvas canvas)
-    {
+    private readonly System.Diagnostics.Stopwatch _sw = new();
+    public void RenderFrame(AudioFeatures features, ISkiaCanvas canvas) {
+        if (!_sw.IsRunning) _sw.Start();
+        long startTicks = _sw.ElapsedTicks;
+
+        _totalPoints = 0; _numPoints = 0;
+
+        // adapt sampling based on prior frame time
+        const long TicksPerMs = 10000;
+        long lastMs = _lastFrameTicks > 0 ? (startTicks - _lastFrameTicks) / TicksPerMs : 16;
+        if (lastMs > _targetMs + 3 && _samplesPerFrame > 1000) _samplesPerFrame = (int)(_samplesPerFrame * 0.85f);
+        else if (lastMs < _targetMs - 3) _samplesPerFrame = (int)(_samplesPerFrame * 1.10f);
+        _samplesPerFrame = Math.Clamp(_samplesPerFrame, 1000, 40000);
         // FIXED: Audio-reactive time and animation updates
         var energy = f.Energy;
         var bass = f.Bass;
@@ -129,8 +140,15 @@
         _numPoints = 0;
         _totalPoints = 0;
 
-        // Start recursive fractal generation
-        Recurse(0.0, 0.0, 0, canvas);
+        // Start progressive sampling instead of deep recursion
+        for (int i = 0; i < _samplesPerFrame && _totalPoints < MAX_POINTS_PER_FRAME; i++)
+        {
+            // seed from a jitter around center
+            double seedx = (Random.Shared.NextDouble() - 0.5) * 0.1;
+            double seedy = (Random.Shared.NextDouble() - 0.5) * 0.1;
+            Recurse(seedx, seedy, 0, canvas);
+        }
+                Recurse(0.0, 0.0, 0, canvas);
 
         // Render any remaining points
         RenderPoints(canvas);
@@ -461,6 +479,5 @@
 
         return (uint)(0xFF << 24 | r << 16 | g << 8 | b);
     }
-}
-
-
+    _lastFrameTicks = _sw.ElapsedTicks;
+    }

--- a/PhoenixVisualizer.Visuals\SpectrumWaveformHybridVisualizer.cs
+++ b/PhoenixVisualizer.Visuals\SpectrumWaveformHybridVisualizer.cs
@@ -402,6 +402,21 @@
             return 0xFF00FFFF; // Default cyan
         }
     }
-}
-
-
+
+        private static uint HsvToRgb(float h, float s, float v)
+        {
+            h = (h % 360f + 360f) % 360f;
+            float c = v * s;
+            float x = c * (1 - MathF.Abs((h / 60f) % 2 - 1));
+            float m = v - c;
+            float r=0,g=0,b=0;
+            if (h < 60)      { r=c; g=x; b=0; }
+            else if (h <120) { r=x; g=c; b=0; }
+            else if (h <180) { r=0; g=c; b=x; }
+            else if (h <240) { r=0; g=x; b=c; }
+            else if (h <300) { r=x; g=0; b=c; }
+            else             { r=c; g=0; b=x; }
+            byte R=(byte)((r+m)*255), G=(byte)((g+m)*255), B=(byte)((b+m)*255);
+            return 0xFF000000u | ((uint)R<<16) | ((uint)G<<8) | (uint)B;
+        }
+    }





