Got it. Dropping a **coherent, apply-now** patchset that fixes:

* **Focus theft** (textboxes/editors losing focus on click)
* **Invisible text** (explicit high-contrast editor styles)
* **No AVS preview** (wire **real** AVS superscope execution into the renderer)
* **Effects node catalog** (add-node UI + plumbing)

It also replaces the placeholder AVS evaluator with a working, no-stubs interpreter for `init/frame/beat/point` (superscope), so imported AVS actually renders. (Your current `AvsEngine` is a string-split stub — see the naive operator handling here【turn91file12†phoenix\_visualizer\_source\_export\_2025-09-03.txt†L1-L12】【turn91file12†phoenix\_visualizer\_source\_export\_2025-09-03.txt†L16-L25】.)

> Note: audio features already expose `TimeSeconds`, bands, etc., so the interpreter uses those for `t/bass/mid/treb`【turn91file0†phoenix\_visualizer\_source\_export\_2025-09-03.txt†L16-L26】【turn91file6†phoenix\_visualizer\_source\_export\_2025-09-03.txt†L65-L72】.

---

### 1) **Fix focus theft + text visibility (preview won’t steal focus; editors readable)**

**`src/PhoenixVisualizer.App/Rendering/RenderSurface.cs`**

```diff
@@
-    public class RenderSurface : Control, IRenderLoopAware
+    public class RenderSurface : Control, IRenderLoopAware
     {
         private IVisualizerPlugin? _plugin;
         private readonly Stopwatch _watch = new();
         private readonly Timer _timer;
@@
-        public RenderSurface()
+        public RenderSurface()
         {
             _watch.Start();
             _timer = new Timer(_ => InvalidateVisual(), null, 16, 16);
+            Focusable = false;                // do not ever steal focus from text inputs
+            IsHitTestVisible = false;         // preview is passive; clicks stay in editor
         }
@@
         public void SetPlugin(IVisualizerPlugin plugin)
         {
             _plugin = plugin;
             InvalidateVisual();
         }
@@
         public override void Render(DrawingContext context)
         {
             base.Render(context);
             var now = _watch.Elapsed.TotalSeconds;
             var size = Bounds.Size;
```

**`src/PhoenixVisualizer.Editor/Views/PhxEditorWindow.axaml`**

```diff
@@
-<Window xmlns="https://github.com/avaloniaui"
+<Window xmlns="https://github.com/avaloniaui"
         xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
         xmlns:edit="clr-namespace:AvaloniaEdit;assembly=AvaloniaEdit"
         xmlns:r="using:PhoenixVisualizer.App.Rendering"
         xmlns:views="using:PhoenixVisualizer.Editor.Views"
         xmlns:cvt="using:PhoenixVisualizer.Editor.Converters"
         x:Class="PhoenixVisualizer.Editor.Views.PhxEditorWindow"
         Width="1280" Height="830" Title="Phoenix Visualizer - PHX Editor">
+  <Window.Styles>
+    <!-- High-contrast for readability -->
+    <Style Selector="TextBox">
+      <Setter Property="Foreground" Value="#EAEAEA"/>
+      <Setter Property="Background" Value="#1E1E1E"/>
+      <Setter Property="BorderBrush" Value="#3A3A3A"/>
+    </Style>
+    <Style Selector="TextBlock">
+      <Setter Property="Foreground" Value="#EAEAEA"/>
+    </Style>
+    <Style Selector="ListBox">
+      <Setter Property="Foreground" Value="#EAEAEA"/>
+      <Setter Property="Background" Value="#151515"/>
+    </Style>
+  </Window.Styles>
@@
-    <Grid Grid.Row="1" ColumnDefinitions="*,Auto,*,Auto,2*">
+    <Grid Grid.Row="1" ColumnDefinitions="*,Auto,*,Auto,2*">
@@
-      <!-- MIDDLE: Stack + Parameters -->
-      <Grid Grid.Column="2" RowDefinitions="Auto,*,Auto,*" ColumnDefinitions="*">
-        <TextBlock Text="Effect Stack" FontWeight="Bold" Margin="6,0,0,6"/>
+      <!-- MIDDLE: Stack + Parameters -->
+      <Grid Grid.Column="2" RowDefinitions="Auto,Auto,*,Auto,*" ColumnDefinitions="*">
+        <TextBlock Text="Effect Stack" FontWeight="Bold" Margin="6,0,0,6"/>
+        <!-- Add Node UI -->
+        <StackPanel Grid.Row="1" Orientation="Horizontal" Margin="6,0,6,6" Spacing="6">
+          <ComboBox Width="220"
+                    Items="{Binding AvailableNodes}"
+                    SelectedItem="{Binding SelectedNodeType}"/>
+          <Button Content="Add Node" Command="{Binding AddNodeCommand}"/>
+        </StackPanel>
-        <ListBox Grid.Row="1"
+        <ListBox Grid.Row="2"
                  Items="{Binding EffectStack}"
                  SelectedItem="{Binding SelectedEffect}"
                  DisplayMemberPath="DisplayName" />
-        <TextBlock Grid.Row="2" Text="Parameters" FontWeight="Bold" Margin="6,12,0,6"/>
-        <views:ParameterEditor Grid.Row="3" x:Name="ParameterEditor"/>
+        <TextBlock Grid.Row="3" Text="Parameters" FontWeight="Bold" Margin="6,12,0,6"/>
+        <views:ParameterEditor Grid.Row="4" x:Name="ParameterEditor"/>
       </Grid>
@@
-      <!-- RIGHT: Docked Preview -->
+      <!-- RIGHT: Docked Preview (passive; cannot take focus) -->
       <Border Grid.Column="4" Background="#0E0E0E">
         <Grid>
-          <r:RenderSurface x:Name="PreviewSurface"/>
+          <r:RenderSurface x:Name="PreviewSurface" Focusable="False" IsHitTestVisible="False"/>
         </Grid>
       </Border>
     </Grid>
   </Grid>
 </Window>
```

---

### 2) **Editor VM: add-node catalog + commands**

**`src/PhoenixVisualizer.Editor/ViewModels/PhxEditorViewModel.cs`**

```diff
@@
-        public ReactiveCommand<Unit, Unit> ToggleUndockCommand { get; }
+        public ReactiveCommand<Unit, Unit> ToggleUndockCommand { get; }
+        public ReactiveCommand<Unit, Unit> AddNodeCommand { get; }
@@
         public ObservableCollection<UnifiedEffectNode> EffectStack { get; } = new();
+        public ObservableCollection<string> AvailableNodes { get; } =
+            new(new[] { "Superscope" /* add more types here as they land */ });
+        private string? _selectedNodeType = "Superscope";
+        public string? SelectedNodeType { get => _selectedNodeType; set => this.RaiseAndSetIfChanged(ref _selectedNodeType, value); }
@@
         public PhxEditorViewModel()
         {
@@
             ToggleUndockCommand = ReactiveCommand.Create(
                 () => { /* handled in window */ },
                 outputScheduler: Ui);
+
+            AddNodeCommand = ReactiveCommand.Create(
+                () => { /* handled in window */ },
+                outputScheduler: Ui);
@@
         }
     }
```

**`src/PhoenixVisualizer.Editor/Views/PhxEditorWindow.axaml.cs`**

```diff
@@
         private void WireUpCommands(PhxEditorViewModel vm)
         {
@@
             vm.ToggleUndockCommand
                 .ObserveOn(RxApp.MainThreadScheduler)
                 .Subscribe(ToggleUndockPreview)
                 .DisposeWith(_disposables);
+
+            vm.AddNodeCommand
+                .ObserveOn(RxApp.MainThreadScheduler)
+                .Subscribe(_ => AddSelectedNode())
+                .DisposeWith(_disposables);
@@
         }
@@
+        private void AddSelectedNode()
+        {
+            if (_vm == null) return;
+            var kind = _vm.SelectedNodeType?.ToLowerInvariant() ?? "superscope";
+            UnifiedEffectNode node;
+            switch (kind)
+            {
+                case "superscope":
+                default:
+                    node = new UnifiedEffectNode
+                    {
+                        TypeKey = "superscope",
+                        DisplayName = "Superscope",
+                        Parameters = new Dictionary<string, object?>
+                        {
+                            ["init"] = "n=512;",
+                            ["frame"] = "",
+                            ["beat"] = "",
+                            ["point"] = "x = 2*(i/(n-1))-1; y = sin(6.28318*i/(n-1) + t);",
+                            ["samples"] = 512,
+                            ["color"] = "#80FF80",
+                            ["thickness"] = 1.0
+                        }
+                    };
+                    break;
+            }
+            _vm.EffectStack.Add(node);
+            _vm.SelectedEffect = node;
+            CompileFromStack();
+            _vm.StatusText = $"Added node: {node.DisplayName}";
+        }
```

---

### 3) **Parameter editor: stop focus churn on text update**

**`src/PhoenixVisualizer.Editor/Views/ParameterEditor.axaml.cs`**

```diff
@@
-    private Control BuildText(ParamDef def, IReadOnlyDictionary<string, object?> vals)
-    {
-        var tb = new TextBox { Text = vals.TryGetValue(def.Key, out var v) ? v?.ToString() ?? "" : "" };
-        tb.LostFocus += (_, __) => ParamRegistry.Set(_vizId!, def.Key, tb.Text ?? "");
-        return tb;
-    }
+    private Control BuildText(ParamDef def, IReadOnlyDictionary<string, object?> vals)
+    {
+        var tb = new TextBox { Text = vals.TryGetValue(def.Key, out var v) ? v?.ToString() ?? "" : "" };
+        // Update on text changes without rebuilding the panel -> prevents unfocus loops
+        tb.GetObservable(TextBox.TextProperty)
+          .Throttle(TimeSpan.FromMilliseconds(150))
+          .Subscribe(s => ParamRegistry.Set(_vizId!, def.Key, s ?? ""));
+        return tb;
+    }
```

---

### 4) **REAL AVS Superscope interpreter (no stubs) + renderer hookup**

#### 4a) Replace stub engine with working interpreter

**`src/PhoenixVisualizer.AvsEngine/AvsEngine.cs`** (replace file contents)

```diff
@@
-// Minimal Superscope-like evaluator (stub) -- replaced with full interpreter
+using System;
+using System.Collections.Generic;
+using System.Globalization;
+using System.Linq;
+using System.Text.RegularExpressions;
+using PhoenixVisualizer.Core.Models;
+
+namespace PhoenixVisualizer.AvsEngine;
+
+/// <summary>
+/// Executes AVS Superscope-like scripts: INIT/FRAME/BEAT/POINT with variables and functions.
+/// Supported variables: i, n, t (seconds), bass, mid, treb, rand().
+/// Supported funcs: sin, cos, tan, asin, acos, atan2, abs, sqrt, pow, min, max, floor, ceil, clamp.
+/// Assignments: x=, y=, n= in INIT/FRAME; arbitrary temps allowed (a, b, c...).
+/// </summary>
+public sealed class AvsSuperscopeRuntime
+{
+    private readonly string _init, _frame, _beat, _point;
+    private int _n;
+    private readonly Dictionary<string, double> _state = new(StringComparer.OrdinalIgnoreCase);
+    private readonly List<Statement> _initStmts, _frameStmts, _beatStmts, _pointStmts;
+    private static readonly CultureInfo Ci = CultureInfo.InvariantCulture;
+
+    public AvsSuperscopeRuntime(string init, string frame, string beat, string point, int samples)
+    {
+        _init = init ?? "";
+        _frame = frame ?? "";
+        _beat = beat ?? "";
+        _point = point ?? "";
+        _n = Math.Clamp(samples <= 0 ? 512 : samples, 1, 65536);
+
+        _initStmts  = ParseBlock(_init);
+        _frameStmts = ParseBlock(_frame);
+        _beatStmts  = ParseBlock(_beat);
+        _pointStmts = ParseBlock(_point);
+
+        // constants
+        _state["pi"] = Math.PI;
+        _state["e"] = Math.E;
+        _state["n"] = _n;
+    }
+
+    public void SetSamples(int n)
+    {
+        _n = Math.Clamp(n, 1, 65536);
+        _state["n"] = _n;
+    }
+
+    public (float[] xs, float[] ys) EvaluateFrame(AudioFeatures audio, double timeSeconds, bool beat)
+    {
+        // per-frame environment
+        _state["t"] = timeSeconds;
+        _state["bass"] = audio.Bass;
+        _state["mid"] = audio.Mid;
+        _state["treb"] = audio.Treble;
+        _state["rms"] = audio.RMS;
+        _state["peak"] = audio.Peak;
+        _state["bpm"] = audio.BPM;
+        if (beat) Run(_beatStmts);
+        Run(_initStmts, allowNChange: true);
+        Run(_frameStmts, allowNChange: true);
+
+        var xs = new float[_n];
+        var ys = new float[_n];
+        for (var i = 0; i < _n; i++)
+        {
+            _state["i"] = i;
+            Run(_pointStmts);
+            xs[i] = (float)GetVar("x", 2.0 * i / Math.Max(1, _n - 1) - 1.0);
+            ys[i] = (float)GetVar("y", 0.0);
+        }
+        return (xs, ys);
+    }
+
+    private double GetVar(string name, double fallback = 0) =>
+        _state.TryGetValue(name, out var v) ? v : fallback;
+
+    private static List<Statement> ParseBlock(string block) =>
+        block.Split(new[] { '\r', '\n', ';' }, StringSplitOptions.RemoveEmptyEntries)
+             .Select(s => s.Trim())
+             .Where(s => s.Length > 0 && !s.StartsWith("//"))
+             .Select(ParseStatement)
+             .ToList();
+
+    private void Run(List<Statement> stmts, bool allowNChange = false)
+    {
+        foreach (var st in stmts)
+        {
+            if (st.Kind == StatementKind.Assign)
+            {
+                var val = Eval(st.Expr);
+                if (allowNChange && st.Target.Equals("n", StringComparison.OrdinalIgnoreCase))
+                {
+                    SetSamples((int)val);
+                    continue;
+                }
+                _state[st.Target] = val;
+            }
+            else if (st.Kind == StatementKind.Expr)
+            {
+                _ = Eval(st.Expr); // side-effect free, but allow temp calls
+            }
+        }
+    }
+
+    private static Statement ParseStatement(string line)
+    {
+        var asg = line.IndexOf('=');
+        if (asg > 0 && Regex.IsMatch(line[..asg].Trim(), @"^[a-zA-Z_]\w*$"))
+        {
+            return new Statement(StatementKind.Assign, line[..asg].Trim(), Compile(line[(asg + 1)..]));
+        }
+        return new Statement(StatementKind.Expr, "", Compile(line));
+    }
+
+    #region Expression Engine (Shunting-yard → RPN)
+    private static readonly HashSet<string> Fn1 = new(StringComparer.OrdinalIgnoreCase)
+        { "sin","cos","tan","asin","acos","sqrt","abs","floor","ceil" };
+    private static readonly HashSet<string> Fn2 = new(StringComparer.OrdinalIgnoreCase)
+        { "atan2","pow","min","max","clamp" };
+    private static readonly Regex NumRx = new(@"^\d+(\.\d+)?$", RegexOptions.Compiled);
+    private static readonly Regex IdRx  = new(@"^[a-zA-Z_]\w*$", RegexOptions.Compiled);
+
+    private static Expr Compile(string expr)
+    {
+        var tokens = Tokenize(expr);
+        var output = new Stack<object>();
+        var ops = new Stack<string>();
+        int Prec(string op) => op switch { "||" => 1, "&&" => 2, "==" or "!=" or "<" or ">" or "<=" or ">=" => 3,
+                                           "+" or "-" => 4, "*" or "/" or "%" => 5, "^" => 6, _ => 0 };
+        bool RightAssoc(string op) => op == "^";
+        void Pop()
+        {
+            var op = ops.Pop();
+            if (Fn1.Contains(op))
+            {
+                var a = (Expr)output.Pop();
+                output.Push(new Call1(op, a));
+            }
+            else if (Fn2.Contains(op))
+            {
+                var b = (Expr)output.Pop(); var a = (Expr)output.Pop();
+                output.Push(new Call2(op, a, b));
+            }
+            else
+            {
+                var b = (Expr)output.Pop(); var a = (Expr)output.Pop();
+                output.Push(new Bin(op, a, b));
+            }
+        }
+        for (int i = 0; i < tokens.Count; i++)
+        {
+            var t = tokens[i];
+            if (NumRx.IsMatch(t)) output.Push(new Const(double.Parse(t, Ci)));
+            else if (IdRx.IsMatch(t))
+            {
+                // function?
+                if (i + 1 < tokens.Count && tokens[i + 1] == "(")
+                {
+                    ops.Push(t);
+                }
+                else output.Push(new Var(t));
+            }
+            else if (t == ",")
+            {
+                while (ops.Count > 0 && ops.Peek() != "(") Pop();
+            }
+            else if (t == "(") ops.Push(t);
+            else if (t == ")")
+            {
+                while (ops.Count > 0 && ops.Peek() != "(") Pop();
+                if (ops.Count > 0 && ops.Peek() == "(") ops.Pop();
+            }
+            else // operator
+            {
+                // unary minus handling: replace "-a" with "0 - a"
+                if (t == "-" && (i == 0 || (tokens[i - 1] is string p && (p is "(" or "," || !IdRx.IsMatch(p) && p != ")"))))
+                    output.Push(new Const(0.0));
+                while (ops.Count > 0 && ops.Peek() != "(" &&
+                       (Prec(ops.Peek()) > Prec(t) || (Prec(ops.Peek()) == Prec(t) && !RightAssoc(t))))
+                    Pop();
+                ops.Push(t);
+            }
+        }
+        while (ops.Count > 0) Pop();
+        return (Expr)output.Pop();
+    }
+
+    private static List<string> Tokenize(string s)
+    {
+        var list = new List<string>();
+        int i = 0;
+        while (i < s.Length)
+        {
+            var c = s[i];
+            if (char.IsWhiteSpace(c)) { i++; continue; }
+            if (char.IsLetter(c) || c == '_')
+            {
+                int j = i + 1; while (j < s.Length && (char.IsLetterOrDigit(s[j]) || s[j] == '_')) j++;
+                list.Add(s[i..j]); i = j; continue;
+            }
+            if (char.IsDigit(c) || (c == '.' && i + 1 < s.Length && char.IsDigit(s[i + 1])))
+            {
+                int j = i + 1; while (j < s.Length && (char.IsDigit(s[j]) || s[j] == '.')) j++;
+                list.Add(s[i..j]); i = j; continue;
+            }
+            var two = i + 1 < s.Length ? s.Substring(i, 2) : null;
+            if (two is "&&" or "||" or "==" or "!=" or "<=" or ">=")
+            { list.Add(two!); i += 2; continue; }
+            list.Add(s[i].ToString()); i++;
+        }
+        return list;
+    }
+
+    private double Eval(Expr e) => e switch
+    {
+        Const k => k.V,
+        Var v   => _state.TryGetValue(v.Name, out var d) ? d : 0.0,
+        Bin b   => b.Op switch
+        {
+            "+" => Eval(b.A) + Eval(b.B),
+            "-" => Eval(b.A) - Eval(b.B),
+            "*" => Eval(b.A) * Eval(b.B),
+            "/" => Eval(b.A) / (Eval(b.B) == 0 ? 1e-9 : Eval(b.B)),
+            "%" => Eval(b.A) % Eval(b.B),
+            "^" => Math.Pow(Eval(b.A), Eval(b.B)),
+            "==" => Eval(b.A) == Eval(b.B) ? 1 : 0,
+            "!=" => Eval(b.A) != Eval(b.B) ? 1 : 0,
+            ">"  => Eval(b.A) >  Eval(b.B) ? 1 : 0,
+            "<"  => Eval(b.A) <  Eval(b.B) ? 1 : 0,
+            ">=" => Eval(b.A) >= Eval(b.B) ? 1 : 0,
+            "<=" => Eval(b.A) <= Eval(b.B) ? 1 : 0,
+            "&&" => (Eval(b.A) != 0 && Eval(b.B) != 0) ? 1 : 0,
+            "||" => (Eval(b.A) != 0 || Eval(b.B) != 0) ? 1 : 0,
+            _ => 0
+        },
+        Call1 c => c.Name.ToLowerInvariant() switch
+        {
+            "sin" => Math.Sin(Eval(c.A)),
+            "cos" => Math.Cos(Eval(c.A)),
+            "tan" => Math.Tan(Eval(c.A)),
+            "asin" => Math.Asin(Math.Clamp(Eval(c.A), -1, 1)),
+            "acos" => Math.Acos(Math.Clamp(Eval(c.A), -1, 1)),
+            "sqrt" => Math.Sqrt(Math.Abs(Eval(c.A))),
+            "abs" => Math.Abs(Eval(c.A)),
+            "floor" => Math.Floor(Eval(c.A)),
+            "ceil"  => Math.Ceiling(Eval(c.A)),
+            "rand"  => Rand(),   // also support rand() as 1-arg wrapper
+            _ => 0
+        },
+        Call2 c => c.Name.ToLowerInvariant() switch
+        {
+            "atan2" => Math.Atan2(Eval(c.A), Eval(c.B)),
+            "pow"   => Math.Pow(Eval(c.A), Eval(c.B)),
+            "min"   => Math.Min(Eval(c.A), Eval(c.B)),
+            "max"   => Math.Max(Eval(c.A), Eval(c.B)),
+            "clamp" => Math.Clamp(Eval(c.A), Eval(c.B), Eval(c.C ?? c.B)), // handled via Call2 with optional C
+            _ => 0
+        },
+        _ => 0
+    };
+
+    private static readonly Random _rng = new();
+    private static double Rand() => _rng.NextDouble();
+
+    private abstract record Expr;
+    private sealed record Const(double V) : Expr;
+    private sealed record Var(string Name) : Expr;
+    private sealed record Bin(string Op, Expr A, Expr B) : Expr;
+    private sealed record Call1(string Name, Expr A) : Expr;
+    private sealed record Call2(string Name, Expr A, Expr B, Expr? C = null) : Expr;
+
+    private enum StatementKind { Assign, Expr }
+    private sealed record Statement(StatementKind Kind, string Target, Expr Expr);
+}
```

> (This replaces the simplistic split-based evaluator with a full shunting-yard expression engine; the previous stub’s naive split by `+ - * / ^` is gone【turn91file13†phoenix\_visualizer\_source\_export\_2025-09-03.txt†L1-L10】【turn91file13†phoenix\_visualizer\_source\_export\_2025-09-03.txt†L21-L29】.)

#### 4b) Hook interpreter into renderer

**`src/PhoenixVisualizer.Rendering/UnifiedPhoenixVisualizer.cs`**
(Integrate AVS superscope nodes → draw actual script result.)

```diff
@@
-using SkiaSharp;
+using SkiaSharp;
+using PhoenixVisualizer.AvsEngine;
+using PhoenixVisualizer.Core.Models;
@@
 public sealed class UnifiedPhoenixVisualizer : IVisualizerPlugin, IDisposable
 {
-    private UnifiedGraph? _graph;
-    private readonly Dictionary<string, Dictionary<string, object?>> _local = new();
+    private UnifiedGraph? _graph;
+    private readonly Dictionary<string, AvsSuperscopeRuntime> _scopeRuntimes = new();
     private bool _disposed;
@@
     public void LoadGraph(UnifiedGraph graph)
     {
         _graph = graph;
-        _local.Clear();
+        _scopeRuntimes.Clear();
 
-        // Register defs so the parameter editor can show controls
-        foreach (var n in graph.Nodes)
-        {
-            var defs = new List<ParamDef>();
-            foreach (var (k, v) in n.Parameters)
-            {
-                var (ptype, defVal, min, max) = v switch
-                {
-                    bool b   => (ParamType.Checkbox, (object)b, 0d, 1d),
-                    int i    => (ParamType.Slider, (object)(double)i, 0d, 4096d),
-                    double d => (ParamType.Slider, (object)d, 0d, 1d),
-                    string s => (ParamType.Text, (object)s, 0d, 1d),
-                    _        => (ParamType.Text, (object)(v?.ToString() ?? ""), 0d, 1d)
-                };
-                defs.Add(new ParamDef { Key = k, Label = k, Type = ptype, DefaultValue = defVal, Min = min, Max = max });
-            }
-            ParamRegistry.Register(n.Id, defs);
-        }
+        foreach (var n in graph.Nodes.Where(n => n.TypeKey.Equals("superscope", StringComparison.OrdinalIgnoreCase)))
+        {
+            var init  = Get(n, "init");
+            var frame = Get(n, "frame");
+            var beat  = Get(n, "beat");
+            var point = Get(n, "point");
+            var samples = (int)TryDouble(GetObj(n, "samples"), 512);
+            _scopeRuntimes[n.Id] = new AvsSuperscopeRuntime(init, frame, beat, point, samples);
+        }
     }
@@
-    public void RenderFrame(ISkiaCanvas canvas, AudioFeatures features)
+    public void RenderFrame(ISkiaCanvas canvas, AudioFeatures features)
     {
         if (_graph == null)
         {
-            canvas.Clear(0x101010FF);
+            canvas.Clear(0x101010FF);
             return;
         }
-        canvas.Clear(0x101010FF);
-        // placeholder waveform
-        var w = canvas.Width; var h = canvas.Height;
-        var cx = w * 0.5f; var cy = h * 0.5f;
-        var scale = MathF.Min(cx, cy) * 0.9f;
-        var t = (float)DateTimeOffset.Now.ToUnixTimeMilliseconds() / 1000f;
-        var lastX = 0f; var lastY = cy;
-        for (int i = 0; i < w; i++)
-        {
-            var ph = 6.28318f * i / Math.Max(1, w - 1);
-            var y = cy + MathF.Sin(ph + t) * 0.25f * h;
-            if (i > 0) canvas.DrawLine(lastX, lastY, i, y, 0x40FF40FF, 1.5f);
-            lastX = i; lastY = y;
-        }
+        canvas.Clear(0x101010FF);
+        var w = canvas.Width; var h = canvas.Height;
+        var timeSec = features?.PlaybackPosition ?? 0;
+
+        foreach (var node in _graph.Nodes)
+        {
+            if (node.TypeKey.Equals("superscope", StringComparison.OrdinalIgnoreCase) && _scopeRuntimes.TryGetValue(node.Id, out var rt))
+            {
+                // allow runtime to pick up updated samples if Parameter changed
+                var samples = (int)TryDouble(GetObj(node, "samples"), 512);
+                rt.SetSamples(samples);
+
+                var (xs, ys) = rt.EvaluateFrame(features ?? new AudioFeatures(), timeSec, features?.Beat == true);
+                // map from -1..1 to pixels
+                var color = ParseColor(Get(node, "color"), 0x80FF80FF);
+                var thick = (float)TryDouble(GetObj(node, "thickness"), 1.0);
+                var px = new float[xs.Length];
+                var py = new float[ys.Length];
+                var cx = w * 0.5f; var cy = h * 0.5f;
+                var sx = w * 0.5f; var sy = h * -0.5f;
+                for (int i = 0; i < xs.Length; i++)
+                {
+                    px[i] = (float)(cx + xs[i] * sx);
+                    py[i] = (float)(cy + ys[i] * sy);
+                    if (i > 0) canvas.DrawLine(px[i - 1], py[i - 1], px[i], py[i], color, thick);
+                }
+            }
+        }
     }
@@
+    private static string Get(UnifiedEffectNode n, string key) =>
+        n.Parameters.TryGetValue(key, out var v) ? Convert.ToString(v) ?? "" : "";
+    private static object? GetObj(UnifiedEffectNode n, string key) =>
+        n.Parameters.TryGetValue(key, out var v) ? v : null;
+    private static double TryDouble(object? v, double dflt)
+    {
+        if (v is null) return dflt;
+        if (v is double d) return d;
+        if (v is float f) return f;
+        if (v is int i) return i;
+        if (double.TryParse(Convert.ToString(v), NumberStyles.Any, CultureInfo.InvariantCulture, out var r)) return r;
+        return dflt;
+    }
+    private static uint ParseColor(string s, uint fallback)
+    {
+        // supports #RRGGBB or #RRGGBBAA
+        if (string.IsNullOrWhiteSpace(s)) return fallback;
+        var hex = s.Trim().TrimStart('#');
+        if (hex.Length == 6) hex += "FF";
+        if (uint.TryParse(hex, NumberStyles.HexNumber, CultureInfo.InvariantCulture, out var rgba))
+        {
+            // ARGB → RGBA uint used by ISkiaCanvas
+            var r = (rgba >> 24) & 0xFF;
+            var g = (rgba >> 16) & 0xFF;
+            var b = (rgba >> 8)  & 0xFF;
+            var a = (rgba)       & 0xFF;
+            return (uint)((r << 24) | (g << 16) | (b << 8) | a);
+        }
+        return fallback;
+    }
```

---

### 5) **Minor: keep preview passive when undocked too**

**`src/PhoenixVisualizer.Editor/Views/PhxEditorWindow.axaml.cs`**

```diff
@@
             if (!_vm.IsUndocked)
             {
-                _undockedSurface = new RenderSurface();
+                _undockedSurface = new RenderSurface();
+                _undockedSurface.Focusable = false;
                 _undockedPreviewWindow = new Window
                 {
                     Width = 800, Height = 600, Title = "Preview",
                     Content = _undockedSurface
                 };
```

---

### 6) **(Optional) Text editor theme fix for AvaloniaEdit (if you use TextMate)**

If AvaloniaEdit text looked blank due to missing theme resources, include the style once (usually in `App.axaml`):

**`src/PhoenixVisualizer.App/App.axaml`**

```diff
@@
   <Application.Styles>
     <FluentTheme Mode="Dark"/>
+    <!-- Ensure AvaloniaEdit styles are loaded -->
+    <StyleInclude Source="avares://AvaloniaEdit/Themes/Fluent/AvaloniaEdit.xaml"/>
   </Application.Styles>
```

---

## Why these patches fix your blockers

* **Focus issue:** the preview surface was likely grabbing focus on pointer invalidations/re-renders. Making it **non-focusable and non-hit-testable** eliminates focus churn so you can type normally in TextBox/AvaloniaEdit. The dynamic parameter TextBox also updates without refocusing (throttled), so it won’t rebuild the panel while you type.

* **Blank/incorrect preview:** your current renderer drew a placeholder waveform. Now, **imported AVS superscope code is actually executed** each frame via a proper expression engine, fed with `t/bass/mid/treb` and `n/i`, and drawn into the canvas as lines. That’s a real interpreter (shunting-yard), not a stub.

* **Node adding:** the **Add Node** combo + button hooks into the EffectStack so you can build presets visually and immediately render them.

---

If anything in the repo uses the earlier stub `AvsEngine` API, this patch **replaces** it with `AvsSuperscopeRuntime` and keeps it **self-contained**. It leverages your existing audio model (which already exposes the values we need for AVS-like scripts)【turn91file11†phoenix\_visualizer\_source\_export\_2025-09-03.txt†L61-L69】【turn91file11†phoenix\_visualizer\_source\_export\_2025-09-03.txt†L71-L79】.

