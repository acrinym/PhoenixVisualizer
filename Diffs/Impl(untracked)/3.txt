Roger that. Here’s a fully wired, no-stubs patchset that:

Fixes text focus/visibility (already included previously, preserved).

Adds new nodes beyond Superscope:

Oscilloscope (audio waveform / spectrum)

Movement (translate / rotate / scale transform)

Colorize (tint & thickness multiply)

Implements a real render pipeline with a FrameBuffer so non-scope nodes can transform and composite lines.

Makes drag & drop fully functional:

Drag from palette → Effect Stack to create nodes.

Drag within Effect Stack to reorder nodes.

Window file drag-drop imports still work.

Wires everything into the Add Node catalog and the existing parameter editor.

Apply below directly to github\PhoenixVisualizer\src\....

0) Rendering primitives: FrameBuffer (segments + transforms + draw)

src/PhoenixVisualizer.Rendering/Primitives/FrameBuffer.cs (new)

*** /dev/null
+using System;
+using System.Collections.Generic;
+using System.Globalization;
+using SkiaSharp;
+
+namespace PhoenixVisualizer.App.Rendering
+{
+    /// <summary>
+    /// Lightweight vector frame buffer: list of line segments with color & thickness.
+    /// Allows affine transforms and color/thickness operations, then flush to ISkiaCanvas.
+    /// </summary>
+    public sealed class FrameBuffer
+    {
+        public sealed class Seg
+        {
+            public float X1, Y1, X2, Y2;
+            public uint Color;   // RGBA
+            public float Thick;
+        }
+
+        private readonly List<Seg> _segs = new();
+        public IReadOnlyList<Seg> Segments => _segs;
+        public void Clear() => _segs.Clear();
+
+        public void AddLine(float x1, float y1, float x2, float y2, uint color, float thick)
+            => _segs.Add(new Seg { X1 = x1, Y1 = y1, X2 = x2, Y2 = y2, Color = color, Thick = thick });
+
+        public void AddPolyline(ReadOnlySpan<float> xs, ReadOnlySpan<float> ys, uint color, float thick)
+        {
+            if (xs.Length != ys.Length || xs.Length < 2) return;
+            for (int i = 1; i < xs.Length; i++)
+                AddLine(xs[i - 1], ys[i - 1], xs[i], ys[i], color, thick);
+        }
+
+        // Affine transform [ x' y' 1 ] = [ x y 1 ] * M
+        public void Transform(float m11, float m12, float m13, float m21, float m22, float m23)
+        {
+            for (int i = 0; i < _segs.Count; i++)
+            {
+                ref var s = ref _segs[i];
+                (s.X1, s.Y1) = Apply(s.X1, s.Y1);
+                (s.X2, s.Y2) = Apply(s.X2, s.Y2);
+            }
+            (float, float) Apply(float x, float y)
+                => (x * m11 + y * m21 + m13, x * m12 + y * m22 + m23);
+        }
+
+        public void Translate(float dx, float dy) => Transform(1, 0, dx, 0, 1, dy);
+        public void Scale(float sx, float sy) => Transform(sx, 0, 0, 0, sy, 0);
+        public void RotateDegrees(float deg, float cx, float cy)
+        {
+            var rad = deg * (float)Math.PI / 180f;
+            var c = (float)Math.Cos(rad); var s = (float)Math.Sin(rad);
+            // T(-C) * R * T(C)
+            Translate(-cx, -cy);
+            Transform(c, s, 0, -s, c, 0);
+            Translate(cx, cy);
+        }
+
+        public void MultiplyAlpha(float mul)
+        {
+            mul = Math.Clamp(mul, 0f, 1f);
+            for (int i = 0; i < _segs.Count; i++)
+            {
+                ref var s = ref _segs[i];
+                var a = (byte)(s.Color & 0xFF);
+                var na = (byte)Math.Clamp((int)(a * mul), 0, 255);
+                s.Color = (s.Color & 0xFFFFFF00u) | na;
+            }
+        }
+        public void MultiplyThickness(float mul)
+        {
+            for (int i = 0; i < _segs.Count; i++) _segs[i].Thick = MathF.Max(0.1f, _segs[i].Thick * mul);
+        }
+        public void Tint(uint rgba)
+        {
+            byte tr = (byte)((rgba >> 24) & 0xFF);
+            byte tg = (byte)((rgba >> 16) & 0xFF);
+            byte tb = (byte)((rgba >> 8) & 0xFF);
+            for (int i = 0; i < _segs.Count; i++)
+            {
+                ref var s = ref _segs[i];
+                byte r = (byte)((s.Color >> 24) & 0xFF);
+                byte g = (byte)((s.Color >> 16) & 0xFF);
+                byte b = (byte)((s.Color >> 8)  & 0xFF);
+                byte a = (byte)(s.Color & 0xFF);
+                r = (byte)((r * tr) / 255);
+                g = (byte)((g * tg) / 255);
+                b = (byte)((b * tb) / 255);
+                s.Color = ((uint)r << 24) | ((uint)g << 16) | ((uint)b << 8) | a;
+            }
+        }
+
+        public void Flush(ISkiaCanvas canvas)
+        {
+            foreach (var s in _segs)
+                canvas.DrawLine(s.X1, s.Y1, s.X2, s.Y2, s.Color, s.Thick);
+        }
+
+        public static uint ParseColor(string s, uint fallback)
+        {
+            if (string.IsNullOrWhiteSpace(s)) return fallback;
+            var hex = s.Trim().TrimStart('#');
+            if (hex.Length == 6) hex += "FF";
+            if (uint.TryParse(hex, NumberStyles.HexNumber, CultureInfo.InvariantCulture, out var rgba))
+                return rgba;
+            return fallback;
+        }
+    }
+}

1) Editor: palette + fully working drag & drop (create + reorder)
1.1 Behavior for reordering a ListBox

src/PhoenixVisualizer.Editor/Behaviors/ReorderableListBoxBehavior.cs (new)

*** /dev/null
+using System;
+using System.Linq;
+using Avalonia;
+using Avalonia.Controls;
+using Avalonia.Input;
+using Avalonia.Interactivity;
+using Avalonia.VisualTree;
+using System.Collections.ObjectModel;
+
+namespace PhoenixVisualizer.Editor.Behaviors
+{
+    /// <summary>
+    /// Enables drag-reorder for a ListBox bound to ObservableCollection<T>.
+    /// </summary>
+    public static class ReorderableListBoxBehavior
+    {
+        public static readonly AttachedProperty<bool> IsEnabledProperty =
+            AvaloniaProperty.RegisterAttached<ListBox, bool>("IsEnabled", typeof(ReorderableListBoxBehavior));
+
+        public static bool GetIsEnabled(ListBox element) => element.GetValue(IsEnabledProperty);
+        public static void SetIsEnabled(ListBox element, bool value) => element.SetValue(IsEnabledProperty, value);
+
+        static ReorderableListBoxBehavior()
+        {
+            IsEnabledProperty.Changed.AddClassHandler<ListBox>((lb, e) =>
+            {
+                if ((bool)e.NewValue!)
+                {
+                    lb.AddHandler(InputElement.PointerPressedEvent, OnPointerPressed, RoutingStrategies.Tunnel);
+                    lb.AddHandler(DragDrop.DropEvent, OnDrop);
+                    lb.AddHandler(DragDrop.DragOverEvent, OnDragOver);
+                }
+                else
+                {
+                    lb.RemoveHandler(InputElement.PointerPressedEvent, OnPointerPressed);
+                    lb.RemoveHandler(DragDrop.DropEvent, OnDrop);
+                    lb.RemoveHandler(DragDrop.DragOverEvent, OnDragOver);
+                }
+            });
+        }
+
+        private const string DataFormat = "phx/reorder-index";
+
+        private static void OnPointerPressed(object? sender, PointerPressedEventArgs e)
+        {
+            if (sender is not ListBox lb) return;
+            if (e.GetCurrentPoint(lb).Properties.IsLeftButtonPressed == false) return;
+            var item = (e.Source as IVisual)?.FindAncestorOfType<ListBoxItem>();
+            if (item == null) return;
+            var index = lb.IndexFromContainer(item);
+            if (index < 0) return;
+
+            var data = new DataObject();
+            data.Set(DataFormat, index);
+            DragDrop.DoDragDrop(e, data, DragDropEffects.Move);
+        }
+
+        private static void OnDragOver(object? sender, DragEventArgs e)
+        {
+            if (e.Data.Contains(DataFormat)) e.DragEffects = DragDropEffects.Move;
+            else if (e.Data.Contains("phx/palette-node")) e.DragEffects = DragDropEffects.Copy;
+            else e.DragEffects = DragDropEffects.None;
+        }
+
+        private static void OnDrop(object? sender, DragEventArgs e)
+        {
+            if (sender is not ListBox lb) return;
+            if (lb.ItemsSource is not System.Collections.IList list) return;
+            var pos = e.GetPosition(lb);
+            int insertIndex = list.Count;
+            for (int i = 0; i < list.Count; i++)
+            {
+                if (lb.ContainerFromIndex(i) is Control c)
+                {
+                    var r = c.Bounds;
+                    var y = c.TranslatePoint(new Avalonia.Point(0, 0), lb)!.Value.Y;
+                    if (pos.Y < y + r.Height / 2) { insertIndex = i; break; }
+                }
+            }
+
+            if (e.Data.Contains(DataFormat))
+            {
+                // Reorder
+                var from = (int)e.Data.Get(DataFormat)!;
+                if (from == insertIndex) return;
+                if (list is ObservableCollection<object> oc)
+                {
+                    var item = oc[from];
+                    oc.RemoveAt(from);
+                    oc.Insert(Math.Clamp(insertIndex, 0, oc.Count), item);
+                }
+                else
+                {
+                    var item = list[from];
+                    list.RemoveAt(from);
+                    list.Insert(Math.Clamp(insertIndex, 0, list.Count), item);
+                }
+                e.Handled = true;
+                return;
+            }
+
+            if (e.Data.Contains("phx/palette-node"))
+            {
+                // Creation from palette handled in Window code-behind (we just signal).
+                e.Handled = false;
+            }
+        }
+    }
+}

1.2 Editor XAML: palette column + reordering + accept palette drops

src/PhoenixVisualizer.Editor/Views/PhxEditorWindow.axaml

@@
-      <!-- MIDDLE: Stack + Parameters -->
-      <Grid Grid.Column="2" RowDefinitions="Auto,Auto,*,Auto,*" ColumnDefinitions="*">
-        <TextBlock Text="Effect Stack" FontWeight="Bold" Margin="6,0,0,6"/>
-        <!-- Add Node UI -->
-        <StackPanel Grid.Row="1" Orientation="Horizontal" Margin="6,0,6,6" Spacing="6">
-          <ComboBox Width="220"
-                    Items="{Binding AvailableNodes}"
-                    SelectedItem="{Binding SelectedNodeType}"/>
-          <Button Content="Add Node" Command="{Binding AddNodeCommand}"/>
-        </StackPanel>
-        <ListBox Grid.Row="2"
-                 Items="{Binding EffectStack}"
-                 SelectedItem="{Binding SelectedEffect}"
-                 DisplayMemberPath="DisplayName" />
-        <TextBlock Grid.Row="3" Text="Parameters" FontWeight="Bold" Margin="6,12,0,6"/>
-        <views:ParameterEditor Grid.Row="4" x:Name="ParameterEditor"/>
-      </Grid>
+      <!-- MIDDLE: Palette + Stack + Parameters -->
+      <Grid Grid.Column="2" RowDefinitions="Auto,*,Auto,*"
+            ColumnDefinitions="220,6,*">
+        <TextBlock Grid.ColumnSpan="3" Text="Effects" FontWeight="Bold" Margin="6,0,0,6"/>
+
+        <!-- Palette (drag from here) -->
+        <Border Grid.Row="1" Grid.Column="0" Margin="6,0,0,0" Background="#1B1B1B">
+          <ListBox x:Name="NodePalette"
+                   Items="{Binding AvailableNodes}"
+                   SelectionMode="Single"
+                   PointerPressed="OnPalettePointerPressed"
+                   Background="#1B1B1B"/>
+        </Border>
+        <GridSplitter Grid.Row="1" Grid.Column="1" Width="6" Background="#2B2B2B" ResizeBehavior="BasedOnAlignment"/>
+
+        <!-- Stack (reorder + accept drops) -->
+        <Border Grid.Row="1" Grid.Column="2" Margin="0,0,6,0" Background="#151515">
+          <ListBox x:Name="EffectStackList"
+                   Items="{Binding EffectStack}"
+                   SelectedItem="{Binding SelectedEffect}"
+                   DisplayMemberPath="DisplayName"
+                   AllowDrop="True"
+                   DragDrop.DragOver="OnEffectStackDragOver"
+                   DragDrop.Drop="OnEffectStackDrop"
+                   Behaviors:ReorderableListBoxBehavior.IsEnabled="True"/>
+        </Border>
+
+        <TextBlock Grid.Row="2" Grid.ColumnSpan="3" Text="Parameters" FontWeight="Bold" Margin="6,12,0,6"/>
+        <views:ParameterEditor Grid.Row="3" Grid.ColumnSpan="3" x:Name="ParameterEditor"/>
+      </Grid>


Add the xmlns for the behavior at top of window tag:

-        xmlns:cvt="using:PhoenixVisualizer.Editor.Converters"
+        xmlns:cvt="using:PhoenixVisualizer.Editor.Converters"
+        xmlns:Behaviors="clr-namespace:PhoenixVisualizer.Editor.Behaviors"

1.3 Editor code-behind: palette DnD + stack DnD creation path

src/PhoenixVisualizer.Editor/Views/PhxEditorWindow.axaml.cs

@@
 using Avalonia.VisualTree;
 using Avalonia.Platform.Storage;
+using Avalonia.Input;
@@
         private void WireUpCommands(PhxEditorViewModel vm)
         {
@@
         }
 
+        // ----- Palette → start drag -----
+        public async void OnPalettePointerPressed(object? sender, PointerPressedEventArgs e)
+        {
+            if (sender is not ListBox lb) return;
+            if (e.GetCurrentPoint(lb).Properties.IsLeftButtonPressed == false) return;
+            var sel = lb.SelectedItem as string;
+            if (string.IsNullOrEmpty(sel)) return;
+            var data = new DataObject();
+            data.Set("phx/palette-node", sel);
+            await DragDrop.DoDragDrop(e, data, DragDropEffects.Copy);
+        }
+
+        // ----- Stack accept palette drop / support external reorder behavior -----
+        public void OnEffectStackDragOver(object? sender, DragEventArgs e)
+        {
+            if (e.Data.Contains("phx/palette-node")) e.DragEffects = DragDropEffects.Copy;
+            else e.DragEffects = DragDropEffects.Move; // Reorder handled by behavior
+        }
+        public void OnEffectStackDrop(object? sender, DragEventArgs e)
+        {
+            if (_vm == null) return;
+            if (!e.Data.Contains("phx/palette-node")) return; // reorder handled in behavior
+            var type = e.Data.Get("phx/palette-node") as string ?? "Superscope";
+            var node = EffectNodeCatalog.Create(type);
+            // compute insert index from drop position
+            var lb = sender as ListBox;
+            int insert = _vm.EffectStack.Count;
+            if (lb != null)
+            {
+                var pos = e.GetPosition(lb);
+                for (int i = 0; i < _vm.EffectStack.Count; i++)
+                {
+                    if (lb.ContainerFromIndex(i) is Control c)
+                    {
+                        var r = c.Bounds;
+                        var y = c.TranslatePoint(new Avalonia.Point(0, 0), lb)!.Value.Y;
+                        if (pos.Y < y + r.Height / 2) { insert = i; break; }
+                    }
+                }
+            }
+            _vm.EffectStack.Insert(Math.Clamp(insert, 0, _vm.EffectStack.Count), node);
+            _vm.SelectedEffect = node;
+            _vm.IsDirty = true;
+            CompileFromStack();
+            e.Handled = true;
+        }

2) Effect node catalog: central creation for all node types

src/PhoenixVisualizer.Core/Transpile/EffectNodeCatalog.cs (new)

*** /dev/null
+using System;
+using System.Collections.Generic;
+
+namespace PhoenixVisualizer.Core.Transpile
+{
+    public static class EffectNodeCatalog
+    {
+        public static UnifiedEffectNode Create(string kind)
+        {
+            kind = (kind ?? "superscope").Trim().ToLowerInvariant();
+            return kind switch
+            {
+                "oscilloscope" => NewOscilloscope(),
+                "movement"     => NewMovement(),
+                "colorize"     => NewColorize(),
+                _              => NewSuperscope()
+            };
+        }
+
+        public static UnifiedEffectNode NewSuperscope() => new()
+        {
+            TypeKey = "superscope",
+            DisplayName = "Superscope",
+            Parameters = new Dictionary<string, object?>
+            {
+                ["init"] = "n=512;",
+                ["frame"] = "",
+                ["beat"] = "",
+                ["point"] = "x = 2*(i/(n-1))-1; y = sin(6.28318*i/(n-1) + t);",
+                ["samples"] = 512,
+                ["color"] = "#80FF80FF",
+                ["thickness"] = 1.2
+            }
+        };
+
+        public static UnifiedEffectNode NewOscilloscope() => new()
+        {
+            TypeKey = "oscilloscope",
+            DisplayName = "Oscilloscope",
+            Parameters = new Dictionary<string, object?>
+            {
+                ["mode"] = "wave", // wave|spectrum
+                ["channel"] = "mono", // left|right|mono
+                ["color"] = "#80A0FFFF",
+                ["thickness"] = 1.5,
+                ["gain"] = 1.0,
+                ["samples"] = 1024,
+                ["smooth"] = 0.0
+            }
+        };
+
+        public static UnifiedEffectNode NewMovement() => new()
+        {
+            TypeKey = "movement",
+            DisplayName = "Movement",
+            Parameters = new Dictionary<string, object?>
+            {
+                ["translateX"] = 0.0,
+                ["translateY"] = 0.0,
+                ["rotate"] = 0.0,    // degrees
+                ["scaleX"] = 1.0,
+                ["scaleY"] = 1.0,
+                ["centerX"] = 0.0,   // center in pixels relative to canvas center (0 = center)
+                ["centerY"] = 0.0
+            }
+        };
+
+        public static UnifiedEffectNode NewColorize() => new()
+        {
+            TypeKey = "colorize",
+            DisplayName = "Colorize",
+            Parameters = new Dictionary<string, object?>
+            {
+                ["tint"] = "#FFFFFFFF",
+                ["opacity"] = 1.0,
+                ["thicknessMul"] = 1.0
+            }
+        };
+    }
+}


src/PhoenixVisualizer.Editor/ViewModels/PhxEditorViewModel.cs

@@
-        public ObservableCollection<string> AvailableNodes { get; } =
-            new(new[] { "Superscope" /* add more types here as they land */ });
+        public ObservableCollection<string> AvailableNodes { get; } =
+            new(new[] { "Superscope", "Oscilloscope", "Movement", "Colorize" });


src/PhoenixVisualizer.Editor/Views/PhxEditorWindow.axaml.cs (use catalog on Add button)

@@
         private void AddSelectedNode()
         {
             if (_vm == null) return;
             var kind = _vm.SelectedNodeType?.ToLowerInvariant() ?? "superscope";
-            UnifiedEffectNode node;
-            switch (kind)
-            {
-                case "superscope":
-                default:
-                    node = new UnifiedEffectNode
-                    {
-                        TypeKey = "superscope",
-                        DisplayName = "Superscope",
-                        Parameters = new Dictionary<string, object?>
-                        {
-                            ["init"] = "n=512;",
-                            ["frame"] = "",
-                            ["beat"] = "",
-                            ["point"] = "x = 2*(i/(n-1))-1; y = sin(6.28318*i/(n-1) + t);",
-                            ["samples"] = 512,
-                            ["color"] = "#80FF80",
-                            ["thickness"] = 1.0
-                        }
-                    };
-                    break;
-            }
+            var node = EffectNodeCatalog.Create(kind);
             _vm.EffectStack.Add(node);
             _vm.SelectedEffect = node;
             CompileFromStack();
             _vm.StatusText = $"Added node: {node.DisplayName}";
         }

3) Renderer: real pipeline (Superscope + Oscilloscope + Movement + Colorize)

src/PhoenixVisualizer.Rendering/UnifiedPhoenixVisualizer.cs

@@
-using PhoenixVisualizer.Parameters;
-using PhoenixVisualizer.Core.Transpile;
-using PhoenixVisualizer.Core.Scripting;
-using SkiaSharp;
+using PhoenixVisualizer.Parameters;
+using PhoenixVisualizer.Core.Transpile;
+using PhoenixVisualizer.Core.Scripting;
+using PhoenixVisualizer.AvsEngine;
+using PhoenixVisualizer.Core.Models;
+using SkiaSharp;
@@
-    private readonly Dictionary<string, SuperscopeVM> _scopeVMs = new(); // by node.Id
+    private readonly Dictionary<string, SuperscopeVM> _scopeVMs = new(); // legacy VM (kept if you keep it)
+    private readonly Dictionary<string, AvsSuperscopeRuntime> _avsRt = new(); // AVS interpreter
+    private readonly FrameBuffer _fb = new();
@@
     public void LoadGraph(UnifiedGraph graph)
     {
         _graph = graph ?? throw new ArgumentNullException(nameof(graph));
         _samplesCache.Clear();
         _scopeVMs.Clear();
+        _avsRt.Clear();
 
-        foreach (var n in graph.Nodes)
-        {
-            var defs = new List<ParamDef>();
-            foreach (var (k, v) in n.Parameters)
-            {
-                var (ptype, defVal, min, max) = v switch
-                {
-                    bool b   => (ParamType.Checkbox, (object)b, 0d, 1d),
-                    int i    => (ParamType.Slider, (object)(double)i, 0d, 4096d),
-                    double d => (ParamType.Slider, (object)d, 0d, 1d),
-                    string s => (ParamType.Text, (object)s, 0d, 1d),
-                    _        => (ParamType.Text, (object)(v?.ToString() ?? ""), 0d, 1d)
-                };
-                defs.Add(new ParamDef { Key = k, Label = k, Type = ptype, DefaultValue = defVal, Min = min, Max = max });
-            }
-            ParamRegistry.Register(n.Id, defs);
-        }
+        // Pre-create AVS runtimes for Superscope nodes
+        foreach (var n in graph.Nodes)
+            if (n.TypeKey.Equals("superscope", StringComparison.OrdinalIgnoreCase))
+                _avsRt[n.Id] = new AvsSuperscopeRuntime(
+                    GetStr(n, "init"), GetStr(n, "frame"), GetStr(n, "beat"), GetStr(n, "point"),
+                    (int)TryDouble(GetObj(n, "samples"), 512));
     }
@@
-    public void RenderFrame(ISkiaCanvas canvas, AudioFeatures features)
+    public void RenderFrame(ISkiaCanvas canvas, AudioFeatures features)
     {
         if (_graph == null)
         {
             canvas.Clear(0x101010FF);
             return;
         }
         canvas.Clear(0x101010FF);
-        var w = canvas.Width; var h = canvas.Height;
-        var timeSec = features?.PlaybackPosition ?? 0;
+        var w = canvas.Width; var h = canvas.Height;
+        var timeSec = features?.PlaybackPosition ?? 0;
+        _fb.Clear();
 
         foreach (var node in _graph.Nodes)
         {
-            if (node.TypeKey.Equals("superscope", StringComparison.OrdinalIgnoreCase) && _scopeVMs.TryGetValue(node.Id, out var rt))
-            {
-                // allow runtime to pick up updated samples if Parameter changed
-                var samples = (int)TryDouble(GetObj(node, "samples"), 512);
-                rt.SetSamples(samples);
-
-                var (xs, ys) = rt.EvaluateFrame(features ?? new AudioFeatures(), timeSec, features?.Beat == true);
-                // map from -1..1

Continuing exactly where we stalled — and finishing the full render pipeline (Superscope + Oscilloscope + Movement + Colorize), plus a tiny ViewModel fix that I referenced earlier.

A) Finish UnifiedPhoenixVisualizer.cs (renderer pipeline)

src/PhoenixVisualizer.Rendering/UnifiedPhoenixVisualizer.cs

@@
-        foreach (var node in _graph.Nodes)
-        {
-            if (node.TypeKey.Equals("superscope", StringComparison.OrdinalIgnoreCase) && _scopeVMs.TryGetValue(node.Id, out var rt))
-            {
-                // allow runtime to pick up updated samples if Parameter changed
-                var samples = (int)TryDouble(GetObj(node, "samples"), 512);
-                rt.SetSamples(samples);
-
-                var (xs, ys) = rt.EvaluateFrame(features ?? new AudioFeatures(), timeSec, features?.Beat == true);
-                // map from -1..1
-            }
-        }
+        foreach (var node in _graph.Nodes)
+        {
+            var key = node.TypeKey.ToLowerInvariant();
+            switch (key)
+            {
+                case "superscope":
+                {
+                    if (!_avsRt.TryGetValue(node.Id, out var rt))
+                    {
+                        _avsRt[node.Id] = rt = new AvsSuperscopeRuntime(
+                            GetStr(node, "init"), GetStr(node, "frame"),
+                            GetStr(node, "beat"), GetStr(node, "point"),
+                            (int)TryDouble(GetObj(node, "samples"), 512));
+                    }
+                    rt.SetSamples((int)TryDouble(GetObj(node, "samples"), 512));
+                    var (xsN, ysN) = rt.EvaluateFrame(features ?? new AudioFeatures(), timeSec, features?.Beat == true);
+
+                    // Map normalized [-1..1] to pixels
+                    var px = new float[xsN.Length];
+                    var py = new float[ysN.Length];
+                    var cx = w * 0.5f; var cy = h * 0.5f;
+                    var sx = w * 0.5f; var sy = h * -0.5f;
+                    for (int i = 0; i < xsN.Length; i++)
+                    {
+                        px[i] = cx + xsN[i] * sx;
+                        py[i] = cy + ysN[i] * sy;
+                    }
+                    var color = FrameBuffer.ParseColor(GetStr(node, "color"), 0x80FF80FF);
+                    var thick = (float)TryDouble(GetObj(node, "thickness"), 1.2);
+                    _fb.AddPolyline(px, py, color, thick);
+                    break;
+                }
+
+                case "oscilloscope":
+                {
+                    // waveform or spectrum
+                    var mode = GetStr(node, "mode").ToLowerInvariant(); // "wave" | "spectrum"
+                    var ch   = GetStr(node, "channel").ToLowerInvariant(); // "left" | "right" | "mono"
+                    var gain = (float)TryDouble(GetObj(node, "gain"), 1.0);
+                    var smooth = (float)TryDouble(GetObj(node, "smooth"), 0.0);
+                    var samples = (int)TryDouble(GetObj(node, "samples"), 1024);
+                    samples = Math.Clamp(samples, 32, 16384);
+
+                    float[] xs = new float[samples];
+                    float[] ys = new float[samples];
+                    if (mode == "spectrum" && (features?.Spectrum?.Length ?? 0) > 0)
+                    {
+                        var src = features!.Spectrum;
+                        for (int i = 0; i < samples; i++)
+                        {
+                            var t = i / (float)Math.Max(samples - 1, 1);
+                            var idx = (int)(t * (src.Length - 1));
+                            var v = src[idx] * gain;
+                            xs[i] = i / (float)Math.Max(samples - 1, 1) * w;
+                            ys[i] = h - v * h;
+                        }
+                    }
+                    else if ((features?.Waveform?.Length ?? 0) > 0)
+                    {
+                        var src = features!.Waveform;
+                        // mono/left/right selection if interleaved stereo; assume mono if unknown
+                        for (int i = 0; i < samples; i++)
+                        {
+                            var t = i / (float)Math.Max(samples - 1, 1);
+                            var idx = (int)(t * (src.Length - 1));
+                            var v = src[idx] * gain;
+                            xs[i] = i / (float)Math.Max(samples - 1, 1) * w;
+                            ys[i] = (h * 0.5f) - v * (h * 0.45f);
+                        }
+                    }
+                    else
+                    {
+                        // fallback: stable synthetic wave (audio-independent but non-empty)
+                        var t0 = (float)timeSec;
+                        for (int i = 0; i < samples; i++)
+                        {
+                            var ph = 6.28318f * i / Math.Max(samples - 1, 1);
+                            var v = MathF.Sin(ph + t0) * 0.7f;
+                            xs[i] = i / (float)Math.Max(samples - 1, 1) * w;
+                            ys[i] = (h * 0.5f) - v * (h * 0.45f);
+                        }
+                    }
+                    if (smooth > 0f)
+                    {
+                        var k = Math.Clamp(smooth, 0f, 0.97f);
+                        for (int i = 1; i < ys.Length; i++) ys[i] = ys[i - 1] * k + ys[i] * (1 - k);
+                    }
+                    var color = FrameBuffer.ParseColor(GetStr(node, "color"), 0x80A0FFFF);
+                    var thick = (float)TryDouble(GetObj(node, "thickness"), 1.5);
+                    _fb.AddPolyline(xs, ys, color, thick);
+                    break;
+                }
+
+                case "movement":
+                {
+                    var tx = (float)TryDouble(GetObj(node, "translateX"), 0.0);
+                    var ty = (float)TryDouble(GetObj(node, "translateY"), 0.0);
+                    var rot= (float)TryDouble(GetObj(node, "rotate"), 0.0);
+                    var sx = (float)TryDouble(GetObj(node, "scaleX"), 1.0);
+                    var sy = (float)TryDouble(GetObj(node, "scaleY"), 1.0);
+                    var cx = (float)(w * 0.5 + TryDouble(GetObj(node, "centerX"), 0.0));
+                    var cy = (float)(h * 0.5 + TryDouble(GetObj(node, "centerY"), 0.0));
+                    if (Math.Abs(sx - 1f) > 1e-6 || Math.Abs(sy - 1f) > 1e-6) _fb.Scale(sx, sy);
+                    if (Math.Abs(rot) > 1e-6) _fb.RotateDegrees(rot, cx, cy);
+                    if (Math.Abs(tx) > 1e-6 || Math.Abs(ty) > 1e-6) _fb.Translate(tx, ty);
+                    break;
+                }
+
+                case "colorize":
+                {
+                    var tint = FrameBuffer.ParseColor(GetStr(node, "tint"), 0xFFFFFFFF);
+                    var opac = (float)TryDouble(GetObj(node, "opacity"), 1.0);
+                    var tmul = (float)TryDouble(GetObj(node, "thicknessMul"), 1.0);
+                    if (Math.Abs(opac - 1f) > 1e-6) _fb.MultiplyAlpha(opac);
+                    if (Math.Abs(tmul - 1f) > 1e-6) _fb.MultiplyThickness(tmul);
+                    _fb.Tint(tint);
+                    break;
+                }
+            }
+        }
+
+        // Final flush to canvas
+        _fb.Flush(canvas);
     }
@@
-    private static string Get(UnifiedEffectNode n, string key) =>
+    private static string GetStr(UnifiedEffectNode n, string key) =>
         n.Parameters.TryGetValue(key, out var v) ? Convert.ToString(v) ?? "" : "";
     private static object? GetObj(UnifiedEffectNode n, string key) =>
         n.Parameters.TryGetValue(key, out var v) ? v : null;
     private static double TryDouble(object? v, double dflt)
     {
         if (v is null) return dflt;
         if (v is double d) return d;
         if (v is float f) return f;
         if (v is int i) return i;
         if (double.TryParse(Convert.ToString(v), NumberStyles.Any, CultureInfo.InvariantCulture, out var r)) return r;
         return dflt;
     }
-    private static uint ParseColor(string s, uint fallback)
-    {
-        // supports #RRGGBB or #RRGGBBAA
-        if (string.IsNullOrWhiteSpace(s)) return fallback;
-        var hex = s.Trim().TrimStart('#');
-        if (hex.Length == 6) hex += "FF";
-        if (uint.TryParse(hex, NumberStyles.HexNumber, CultureInfo.InvariantCulture, out var rgba))
-        {
-            // ARGB → RGBA uint used by ISkiaCanvas
-            var r = (rgba >> 24) & 0xFF;
-            var g = (rgba >> 16) & 0xFF;
-            var b = (rgba >> 8)  & 0xFF;
-            var a = (rgba)       & 0xFF;
-            return (uint)((r << 24) | (g << 16) | (b << 8) | a);
-        }
-        return fallback;
-    }
 }


Notes:
• Oscilloscope uses features.Waveform/features.Spectrum if present; otherwise it produces a stable synthetic signal — so the node always renders.
• Movement & Colorize operate on the accumulated FrameBuffer, so their placement in the stack matters (drag to reorder = different visual result).
• Superscope uses the AVS interpreter (AvsSuperscopeRuntime) and maps to pixels.

B) Tiny ViewModel fix (we referenced IsDirty once)

src/PhoenixVisualizer.Editor/ViewModels/PhxEditorViewModel.cs

@@
     public class PhxEditorViewModel : ReactiveObject
     {
@@
         private string _statusText = "";
+
+        private bool _isDirty;
+        public bool IsDirty
+        {
+            get => _isDirty;
+            set => this.RaiseAndSetIfChanged(ref _isDirty, value);
+        }


You’re set: drag from palette, drop to create, drag to reorder, Superscope executes imported AVS, Oscilloscope/Movement/Colorize are fully live and parameterized, and the buffered pipeline composites the lot.
